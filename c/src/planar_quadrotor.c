#include "planar_quadrotor.h"

//========================================
// Planar quadrotor model parameters
//========================================
// struct tiny_Model_PlanarQuadrotor {
//   double g;
//   double m;
//   double l;
//   double J;
//   double umin[2];
//   double umax[2];
// } tiny_DefaultModel_PlanarQuadrotor = {9.81, 1,      0.018,
//                                        0.3,  {0, 0}, {19.62, 19.62}};

//========================================
// Codes generated from julia/planar_quad_gen
// Discrete dynamics of planar quadrotor
//========================================
void tiny_DiscreteDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = 0.16666666666666666 *
              (0.2 * (0.05 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]) + x[3]) +
               0.1 * (0.1 * (u[0] + u[1]) *
                          sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) +
                                      x[5]) +
                              x[2]) +
                      x[3]) +
               0.2 * (0.05 * (u[0] + u[1]) * sin(x[2]) + x[3]) + 0.1 * x[3]) +
          x[0];
  xn[1] = 0.16666666666666666 *
              (0.2 * (0.05 * (-9.81 + (u[0] + u[1]) * cos(0.05 * x[5] + x[2])) +
                      x[4]) +
               0.2 * (0.05 * (-9.81 + (u[0] + u[1]) * cos(x[2])) + x[4]) +
               0.1 * (0.1 * (-9.81 + (u[0] + u[1]) *
                                         cos(0.05 * (0.41666666666666674 *
                                                         (-1 * u[0] + u[1]) +
                                                     x[5]) +
                                             x[2])) +
                      x[4]) +
               0.1 * x[4]) +
          x[1];
  xn[2] = 0.16666666666666666 *
              (0.4 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
               0.1 * (0.8333333333333335 * (-1 * u[0] + u[1]) + x[5]) +
               0.1 * x[5]) +
          x[2];
  xn[3] =
      0.16666666666666666 *
          (0.1 * (u[0] + u[1]) *
               sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                   x[2]) +
           0.2 * (u[0] + u[1]) *
               sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                   x[2]) +
           0.2 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]) +
           0.1 * (u[0] + u[1]) * sin(x[2])) +
      x[3];
  xn[4] =
      0.16666666666666666 *
          (0.1 * (-9.81 + (u[0] + u[1]) * cos(0.1 * (0.41666666666666674 *
                                                         (-1 * u[0] + u[1]) +
                                                     x[5]) +
                                              x[2])) +
           0.2 * (-9.81 + (u[0] + u[1]) * cos(0.05 * (0.41666666666666674 *
                                                          (-1 * u[0] + u[1]) +
                                                      x[5]) +
                                              x[2])) +
           0.2 * (-9.81 + (u[0] + u[1]) * cos(0.05 * x[5] + x[2])) +
           0.1 * (-9.81 + (u[0] + u[1]) * cos(x[2]))) +
      x[4];
  xn[5] = 0.8333333333333336 * (-1 * u[0] + u[1]) + x[5];
}

void tiny_DiscreteDynamics(Matrix* xn, const Matrix x, const Matrix u) {
  tiny_DiscreteDynamics_Raw(xn->data, x.data, u.data);
}

//========================================
// Codes generated from julia/planar_quad_gen
// Jacobians of discrete dynamics of planar quadrotor
//========================================
void tiny_GetJacobianA_Raw(double* A, const double* x, const double* u) {
  A[0] = 1;
  A[1] = 0;
  A[2] = 0;
  A[3] = 0;
  A[4] = 0;
  A[5] = 0;
  A[6] = 0;
  A[7] = 1;
  A[8] = 0;
  A[9] = 0;
  A[10] = 0;
  A[11] = 0;
  A[12] = 0.16666666666666666 *
          (0.01 * (u[0] + u[1]) *
               cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                   x[2]) +
           0.01 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]) +
           0.01 * (u[0] + u[1]) * cos(x[2]));
  A[13] = 0.16666666666666666 *
          (-0.01 * (u[0] + u[1]) *
               sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                   x[2]) +
           -0.01 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]) +
           -0.01 * (u[0] + u[1]) * sin(x[2]));
  A[14] = 1;
  A[15] =
      0.16666666666666666 *
      (0.1 * (u[0] + u[1]) *
           cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]) +
       0.1 * (u[0] + u[1]) * cos(x[2]) +
       0.2 * (u[0] + u[1]) *
           cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
               x[2]) +
       0.2 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]));
  A[16] =
      0.16666666666666666 *
      (-0.1 * (u[0] + u[1]) *
           sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]) +
       -0.2 * (u[0] + u[1]) *
           sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
               x[2]) +
       -0.2 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]) +
       -0.1 * (u[0] + u[1]) * sin(x[2]));
  A[17] = 0;
  A[18] = 0.1;
  A[19] = 0;
  A[20] = 0;
  A[21] = 1;
  A[22] = 0;
  A[23] = 0;
  A[24] = 0;
  A[25] = 0.1;
  A[26] = 0;
  A[27] = 0;
  A[28] = 1;
  A[29] = 0;
  A[30] = 0.16666666666666666 *
          (0.0005 * (u[0] + u[1]) *
               cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                   x[2]) +
           0.0005 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]));
  A[31] = 0.16666666666666666 *
          (-0.0005 * (u[0] + u[1]) *
               sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                   x[2]) +
           -0.0005 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]));
  A[32] = 0.1;
  A[33] =
      0.16666666666666666 *
      (0.01 * (u[0] + u[1]) *
           cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
               x[2]) +
       0.01 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]) +
       0.01 * (u[0] + u[1]) *
           cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]));
  A[34] =
      0.16666666666666666 *
      (-0.01 * (u[0] + u[1]) *
           sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
               x[2]) +
       -0.01 * (u[0] + u[1]) *
           sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]) +
       -0.01 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]));
  A[35] = 1;
}

void tiny_GetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] =
      0.16666666666666666 *
      (0.01 * sin(0.05 * x[5] + x[2]) + 0.01 * sin(x[2]) +
       0.1 *
           (0.1 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                      x[2]) +
            -0.002083333333333334 * (u[0] + u[1]) *
                cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                    x[2])));
  B[1] =
      0.16666666666666666 *
      (0.01 *
           (0.02083333333333334 * (u[0] + u[1]) *
                sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                    x[2]) +
            cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                x[2])) +
       0.01 * cos(0.05 * x[5] + x[2]) + 0.01 * cos(x[2]));
  B[2] = -0.04166666666666667;
  B[3] =
      0.16666666666666666 *
      (0.2 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                 x[2]) +
       0.1 *
           sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]) +
       0.1 * sin(x[2]) + 0.2 * sin(0.05 * x[5] + x[2]) +
       -0.004166666666666668 * (u[0] + u[1]) *
           cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
               x[2]) +
       -0.004166666666666668 * (u[0] + u[1]) *
           cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]));
  B[4] =
      0.16666666666666666 *
      (0.2 * (0.02083333333333334 * (u[0] + u[1]) *
                  sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                      x[2]) +
              cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                  x[2])) +
       0.1 * (0.04166666666666668 * (u[0] + u[1]) *
                  sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                      x[2]) +
              cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                  x[2])) +
       0.2 * cos(0.05 * x[5] + x[2]) + 0.1 * cos(x[2]));
  B[5] = -0.8333333333333336;
  B[6] =
      0.16666666666666666 *
      (0.01 * sin(0.05 * x[5] + x[2]) + 0.01 * sin(x[2]) +
       0.1 *
           (0.1 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                      x[2]) +
            0.002083333333333334 * (u[0] + u[1]) *
                cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                    x[2])));
  B[7] =
      0.16666666666666666 *
      (0.01 *
           (-0.02083333333333334 * (u[0] + u[1]) *
                sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                    x[2]) +
            cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                x[2])) +
       0.01 * cos(0.05 * x[5] + x[2]) + 0.01 * cos(x[2]));
  B[8] = 0.04166666666666667;
  B[9] =
      0.16666666666666666 *
      (0.2 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                 x[2]) +
       0.1 *
           sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]) +
       0.1 * sin(x[2]) + 0.2 * sin(0.05 * x[5] + x[2]) +
       0.004166666666666668 * (u[0] + u[1]) *
           cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
               x[2]) +
       0.004166666666666668 * (u[0] + u[1]) *
           cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) + x[2]));
  B[10] =
      0.16666666666666666 *
      (0.1 * (-0.04166666666666668 * (u[0] + u[1]) *
                  sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                      x[2]) +
              cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                  x[2])) +
       0.1 * cos(x[2]) +
       0.2 * (-0.02083333333333334 * (u[0] + u[1]) *
                  sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                      x[2]) +
              cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
                  x[2])) +
       0.2 * cos(0.05 * x[5] + x[2]));
  B[11] = 0.8333333333333336;
}

void tiny_GetJacobians(Matrix* A, Matrix* B, const Matrix x, const Matrix u) {
  tiny_GetJacobianA_Raw(A->data, x.data, u.data);
  tiny_GetJacobianB_Raw(B->data, x.data, u.data);
}