#include "quadrotor.h"

//========================================
// Planar quadrotor model parameters
//========================================

//========================================
// Codes generated from julia/quadrotor_quat/quadrotor_gen
// Discrete dynamics of quadrotor
//========================================
void tiny_QuadNonlinearDynamics_Raw(sfloat* xn, const sfloat* x,
                                    const sfloat* u) {
  xn[0] = -6.913104030861153e-7 * u[1] + -1.9236700703482128e-5 * u[0] +
          1.1118591159227945e-6 * u[3] + 1.307999958e-5 * x[10] +
          1.8816151990645456e-5 * u[2] + 0.003923999874 * x[4] + 0.02 * x[6] +
          x[0];
  xn[1] = -8.264867750693335e-7 * u[0] + -1.899494599325163e-5 * u[1] +
          9.766827439395763e-7 * u[2] + 1.8844750024381385e-5 * u[3] +
          -0.003923999874 * x[3] + -1.307999958e-5 * x[9] + 0.02 * x[7] + x[1];
  xn[2] = 0.0009809999685 * u[0] + 0.0009809999685 * u[1] +
          0.0009809999685 * u[2] + 0.0009809999685 * u[3] + 0.02 * x[8] + x[2];
  xn[3] = 0.001263741286862233 * u[0] + 0.029044260861133184 * u[1] +
          -0.0014933987389922777 * u[2] + -0.028814603409003138 * u[3] +
          0.01 * x[9] + x[3];
  xn[4] = -0.0010570495799451932 * u[1] + -0.029413916393232986 * u[0] +
          0.0017000904459093177 * u[3] + 0.01 * x[10] +
          0.02877087552726887 * u[2] + x[4];
  xn[5] = -0.0036442852709168503 * u[1] + 0.004771451728430982 * u[0] +
          0.0012647116383870192 * u[2] + -0.0023918780959011495 * u[3] +
          0.01 * x[11] + x[5];
  xn[6] = -0.00013826209393604777 * u[1] + -0.0038473405113117714 * u[0] +
          0.0002223718446056985 * u[3] + 0.0019620000630000004 * x[10] +
          0.0037632307606421216 * u[2] + 0.3924 * x[4] + x[6];
  xn[7] = -0.0001652973709370069 * u[0] + -0.003798989564608012 * u[1] +
          0.0001953365676047393 * u[2] + 0.003768950367940279 * u[3] +
          -0.3924 * x[3] + -0.0019620000630000004 * x[9] + x[7];
  xn[8] = 0.09809999685000002 * u[0] + 0.09809999685000002 * u[1] +
          0.09809999685000002 * u[2] + 0.09809999685000002 * u[3] + x[8];
  xn[9] = 0.2527482573724466 * u[0] + 5.808852172226636 * u[1] +
          -0.2986797477984556 * u[2] + -5.762920681800629 * u[3] + x[9];
  xn[10] = -0.2114099159890387 * u[1] + -5.882783278646597 * u[0] +
           0.34001808918186355 * u[3] + 5.754175105453773 * u[2] + x[10];
  xn[11] = -0.72885705418337 * u[1] + 0.9542903456861964 * u[0] +
           0.2529423276774038 * u[2] + -0.4783756191802299 * u[3] + x[11];
}

void tiny_QuadNonlinearDynamics(Matrix* xn, const Matrix x, const Matrix u) {
  tiny_QuadNonlinearDynamics_Raw(xn->data, x.data, u.data);
}

// //========================================
// // Codes generated from julia/quadrotor_quat/quadrotor_gen
// // Jacobians of discrete dynamics of quadrotor
// //========================================
// void tiny_QuadGetJacobianA_Raw(sfloat* A, const sfloat* x, const sfloat* u) {
//   A[0] = 1;
//   A[1] = 0;
//   A[2] = 0;
//   A[3] = 0;
//   A[4] = 0;
//   A[5] = 0;
//   A[6] = 0;
//   A[7] = 1;
//   A[8] = 0;
//   A[9] = 0;
//   A[10] = 0;
//   A[11] = 0;
//   A[12] = 0.16666666666666666 *
//           (0.01 * (u[0] + u[1]) *
//                cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                    x[2]) +
//            0.01 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]) +
//            0.01 * (u[0] + u[1]) * cos(x[2]));
//   A[13] = 0.16666666666666666 *
//           (-0.01 * (u[0] + u[1]) *
//                sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                    x[2]) +
//            -0.01 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]) +
//            -0.01 * (u[0] + u[1]) * sin(x[2]));
//   A[14] = 1;
//   A[15] =
//       0.16666666666666666 *
//       (0.1 * (u[0] + u[1]) *
//            cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]) +
//        0.1 * (u[0] + u[1]) * cos(x[2]) +
//        0.2 * (u[0] + u[1]) *
//            cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                x[2]) +
//        0.2 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]));
//   A[16] =
//       0.16666666666666666 *
//       (-0.1 * (u[0] + u[1]) *
//            sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]) +
//        -0.2 * (u[0] + u[1]) *
//            sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                x[2]) +
//        -0.2 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]) +
//        -0.1 * (u[0] + u[1]) * sin(x[2]));
//   A[17] = 0;
//   A[18] = 0.1;
//   A[19] = 0;
//   A[20] = 0;
//   A[21] = 1;
//   A[22] = 0;
//   A[23] = 0;
//   A[24] = 0;
//   A[25] = 0.1;
//   A[26] = 0;
//   A[27] = 0;
//   A[28] = 1;
//   A[29] = 0;
//   A[30] = 0.16666666666666666 *
//           (0.0005 * (u[0] + u[1]) *
//                cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                    x[2]) +
//            0.0005 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]));
//   A[31] = 0.16666666666666666 *
//           (-0.0005 * (u[0] + u[1]) *
//                sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                    x[2]) +
//            -0.0005 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]));
//   A[32] = 0.1;
//   A[33] =
//       0.16666666666666666 *
//       (0.01 * (u[0] + u[1]) *
//            cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                x[2]) +
//        0.01 * (u[0] + u[1]) * cos(0.05 * x[5] + x[2]) +
//        0.01 * (u[0] + u[1]) *
//            cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]));
//   A[34] =
//       0.16666666666666666 *
//       (-0.01 * (u[0] + u[1]) *
//            sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                x[2]) +
//        -0.01 * (u[0] + u[1]) *
//            sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]) +
//        -0.01 * (u[0] + u[1]) * sin(0.05 * x[5] + x[2]));
//   A[35] = 1;
// }

// void tiny_QuadGetJacobianB_Raw(sfloat* B, const sfloat* x, const sfloat* u) {
//   B[0] =
//       0.16666666666666666 *
//       (0.01 * sin(0.05 * x[5] + x[2]) + 0.01 * sin(x[2]) +
//        0.1 *
//            (0.1 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) +
//            x[5]) +
//                       x[2]) +
//             -0.002083333333333334 * (u[0] + u[1]) *
//                 cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5])
//                 +
//                     x[2])));
//   B[1] =
//       0.16666666666666666 *
//       (0.01 *
//            (0.02083333333333334 * (u[0] + u[1]) *
//                 sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5])
//                 +
//                     x[2]) +
//             cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                 x[2])) +
//        0.01 * cos(0.05 * x[5] + x[2]) + 0.01 * cos(x[2]));
//   B[2] = -0.04166666666666667;
//   B[3] =
//       0.16666666666666666 *
//       (0.2 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                  x[2]) +
//        0.1 *
//            sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]) +
//        0.1 * sin(x[2]) + 0.2 * sin(0.05 * x[5] + x[2]) +
//        -0.004166666666666668 * (u[0] + u[1]) *
//            cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                x[2]) +
//        -0.004166666666666668 * (u[0] + u[1]) *
//            cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]));
//   B[4] =
//       0.16666666666666666 *
//       (0.2 * (0.02083333333333334 * (u[0] + u[1]) *
//                   sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) +
//                   x[5]) +
//                       x[2]) +
//               cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                   x[2])) +
//        0.1 * (0.04166666666666668 * (u[0] + u[1]) *
//                   sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5])
//                   +
//                       x[2]) +
//               cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                   x[2])) +
//        0.2 * cos(0.05 * x[5] + x[2]) + 0.1 * cos(x[2]));
//   B[5] = -0.8333333333333336;
//   B[6] =
//       0.16666666666666666 *
//       (0.01 * sin(0.05 * x[5] + x[2]) + 0.01 * sin(x[2]) +
//        0.1 *
//            (0.1 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) +
//            x[5]) +
//                       x[2]) +
//             0.002083333333333334 * (u[0] + u[1]) *
//                 cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5])
//                 +
//                     x[2])));
//   B[7] =
//       0.16666666666666666 *
//       (0.01 *
//            (-0.02083333333333334 * (u[0] + u[1]) *
//                 sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5])
//                 +
//                     x[2]) +
//             cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                 x[2])) +
//        0.01 * cos(0.05 * x[5] + x[2]) + 0.01 * cos(x[2]));
//   B[8] = 0.04166666666666667;
//   B[9] =
//       0.16666666666666666 *
//       (0.2 * sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                  x[2]) +
//        0.1 *
//            sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]) +
//        0.1 * sin(x[2]) + 0.2 * sin(0.05 * x[5] + x[2]) +
//        0.004166666666666668 * (u[0] + u[1]) *
//            cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                x[2]) +
//        0.004166666666666668 * (u[0] + u[1]) *
//            cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//            x[2]));
//   B[10] =
//       0.16666666666666666 *
//       (0.1 * (-0.04166666666666668 * (u[0] + u[1]) *
//                   sin(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5])
//                   +
//                       x[2]) +
//               cos(0.1 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                   x[2])) +
//        0.1 * cos(x[2]) +
//        0.2 * (-0.02083333333333334 * (u[0] + u[1]) *
//                   sin(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) +
//                   x[5]) +
//                       x[2]) +
//               cos(0.05 * (0.41666666666666674 * (-1 * u[0] + u[1]) + x[5]) +
//                   x[2])) +
//        0.2 * cos(0.05 * x[5] + x[2]));
//   B[11] = 0.8333333333333336;
// }

// void tiny_QuadGetJacobians(Matrix* A, Matrix* B, const Matrix x,
//                             const Matrix u) {
//   tiny_QuadGetJacobianA_Raw(A->data, x.data, u.data);
//   tiny_QuadGetJacobianB_Raw(B->data, x.data, u.data);
// }